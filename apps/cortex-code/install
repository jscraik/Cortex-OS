#!/usr/bin/env bash
set -euo pipefail

# Cortex Code Installer - Zero-Config Setup
# Inspired by OpenCode's installation approach
# Licensed under MIT - see LICENSE file

VERSION="2.0.0"
BINARY_NAME="cortex-code"
INSTALL_DIR="$HOME/.cortex/bin"
CONFIG_DIR="$HOME/.cortex"
REPO_URL="https://github.com/cortex-os/cortex-code"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Emojis
ROCKET="ğŸš€"
CHECK="âœ…"
CROSS="âŒ"
GEAR="âš™ï¸"
SPARKLES="âœ¨"
PACKAGE="ğŸ“¦"

print_header() {
    echo -e "${PURPLE}"
    echo "    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "    â•‘                                                           â•‘"
    echo "    â•‘        ${SPARKLES} CORTEX CODE v${VERSION} INSTALLER ${SPARKLES}              â•‘"
    echo "    â•‘                                                           â•‘"
    echo "    â•‘    AI-Powered Terminal Interface for Cortex-OS            â•‘"
    echo "    â•‘                                                           â•‘"
    echo "    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

log_info() {
    echo -e "${BLUE}${GEAR}${NC} $1"
}

log_success() {
    echo -e "${GREEN}${CHECK}${NC} $1"
}

log_error() {
    echo -e "${RED}${CROSS}${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}âš ï¸${NC}  $1"
}

detect_os() {
    case "$(uname -s)" in
        Linux*)     OS="linux";;
        Darwin*)    OS="darwin";;
        CYGWIN*|MINGW*|MSYS*) OS="windows";;
        *)          OS="unknown";;
    esac
}

detect_arch() {
    case "$(uname -m)" in
        x86_64|amd64) ARCH="x86_64";;
        arm64|aarch64) ARCH="aarch64";;
        armv7l) ARCH="armv7";;
        *) ARCH="unknown";;
    esac
}

check_dependencies() {
    local missing_deps=()

    # Check for required tools
    if ! command -v curl &> /dev/null; then
        missing_deps+=("curl")
    fi

    if ! command -v tar &> /dev/null && ! command -v unzip &> /dev/null; then
        missing_deps+=("tar or unzip")
    fi

    # Check for optional but recommended tools
    if ! command -v git &> /dev/null; then
        log_warning "Git not found - some features will be limited"
    fi

    if ! command -v python3 &> /dev/null; then
        log_warning "Python 3 not found - MLX provider will not work"
    fi

    if [ ${#missing_deps[@]} -ne 0 ]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        echo "Please install the missing dependencies and run this script again."
        exit 1
    fi
}

download_binary() {
    local download_url
    local filename

    if [ "$OS" = "unknown" ] || [ "$ARCH" = "unknown" ]; then
        log_error "Unsupported platform: $OS-$ARCH"
        echo "Please build from source: cargo install --git $REPO_URL"
        exit 1
    fi

    # Construct download URL (GitHub releases)
    download_url="$REPO_URL/releases/download/v$VERSION/$BINARY_NAME-$OS-$ARCH"
    filename="$BINARY_NAME-$OS-$ARCH"

    if [ "$OS" = "windows" ]; then
        download_url="$download_url.exe"
        filename="$filename.exe"
    fi

    log_info "Downloading $BINARY_NAME v$VERSION for $OS-$ARCH..."

    # Create install directory
    mkdir -p "$INSTALL_DIR"

    # Download binary
    if ! curl -fsSL "$download_url" -o "$INSTALL_DIR/$BINARY_NAME"; then
        log_error "Failed to download binary from $download_url"
        echo ""
        echo "Alternative installation methods:"
        echo "  1. Build from source: cargo install --git $REPO_URL"
        echo "  2. Download manually from: $REPO_URL/releases"
        exit 1
    fi

    # Make executable
    chmod +x "$INSTALL_DIR/$BINARY_NAME"
    log_success "Downloaded and installed binary"
}

setup_config() {
    log_info "Setting up configuration..."

    # Create config directory
    mkdir -p "$CONFIG_DIR"

    # Copy default configuration if it doesn't exist
    if [ ! -f "$CONFIG_DIR/cortex.json" ]; then
        cat > "$CONFIG_DIR/cortex.json" << 'EOF'
{
  "providers": {
    "default": "github",
    "config": {
      "github": {
        "free_tier": true
      }
    }
  },
  "features": {
    "tui": { "enabled": true },
    "memory": { "enabled": true },
    "metrics": { "enabled": true }
  }
}
EOF
        log_success "Created default configuration"
    else
        log_info "Using existing configuration"
    fi

    # Create AGENTS.md if it doesn't exist
    if [ ! -f "$CONFIG_DIR/AGENTS.md" ]; then
        cat > "$CONFIG_DIR/AGENTS.md" << 'EOF'
# Cortex Agent Memory

This file stores persistent memory for your AI conversations.

## Conversation History

*Conversations will be automatically recorded here*

## Learned Preferences

*Your preferences and patterns will be learned over time*

## Project Context

*Relevant project information will be stored here*
EOF
        log_success "Created AGENTS.md memory file"
    fi
}

setup_shell_integration() {
    log_info "Setting up shell integration..."

    local shell_rc=""
    local shell_name=""

    # Detect shell
    if [ -n "${BASH_VERSION:-}" ]; then
        shell_name="bash"
        shell_rc="$HOME/.bashrc"
        if [ "$(uname)" = "Darwin" ]; then
            shell_rc="$HOME/.bash_profile"
        fi
    elif [ -n "${ZSH_VERSION:-}" ]; then
        shell_name="zsh"
        shell_rc="$HOME/.zshrc"
    elif [ -n "${FISH_VERSION:-}" ]; then
        shell_name="fish"
        shell_rc="$HOME/.config/fish/config.fish"
    else
        log_warning "Unknown shell - manual PATH setup required"
        return
    fi

    # Add to PATH if not already present
    local path_export="export PATH=\"\$HOME/.cortex/bin:\$PATH\""

    if [ -f "$shell_rc" ] && grep -q ".cortex/bin" "$shell_rc"; then
        log_info "$shell_name PATH already configured"
    else
        echo "" >> "$shell_rc"
        echo "# Cortex Code" >> "$shell_rc"
        echo "$path_export" >> "$shell_rc"
        log_success "Added to $shell_name PATH"
    fi

    # Create alias for convenience
    local alias_cmd="alias cortex='cortex-code'"
    if [ -f "$shell_rc" ] && ! grep -q "alias cortex=" "$shell_rc"; then
        echo "$alias_cmd" >> "$shell_rc"
        log_success "Created 'cortex' alias"
    fi
}

install_mcp_servers() {
    log_info "Installing MCP servers..."

    # Check if we're in a Cortex-OS workspace
    if [ -f "package.json" ] && grep -q "cortex-os" "package.json" 2>/dev/null; then
        log_info "Detected Cortex-OS workspace - using local MCP servers"
        return
    fi

    # Install basic MCP servers if available
    local mcp_servers=("cortex-mcp-fs" "cortex-mcp-git" "cortex-mcp-web")
    local installed_count=0

    for server in "${mcp_servers[@]}"; do
        if command -v npm &> /dev/null; then
            if npm list -g "$server" &> /dev/null; then
                log_info "$server already installed"
                ((installed_count++))
            else
                log_info "Installing $server..."
                if npm install -g "$server" &> /dev/null; then
                    log_success "Installed $server"
                    ((installed_count++))
                else
                    log_warning "Failed to install $server (optional)"
                fi
            fi
        fi
    done

    if [ $installed_count -eq 0 ]; then
        log_warning "No MCP servers installed - some features will be limited"
        echo "  To install MCP servers later: npm install -g cortex-mcp-fs cortex-mcp-git"
    else
        log_success "Installed $installed_count MCP servers"
    fi
}

verify_installation() {
    log_info "Verifying installation..."

    # Test binary execution
    if "$INSTALL_DIR/$BINARY_NAME" --version &> /dev/null; then
        log_success "Binary is working correctly"
    else
        log_error "Binary verification failed"
        exit 1
    fi

    # Test configuration
    if [ -f "$CONFIG_DIR/cortex.json" ]; then
        log_success "Configuration file exists"
    else
        log_error "Configuration file missing"
        exit 1
    fi
}

print_success_message() {
    echo ""
    echo -e "${GREEN}"
    echo "    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "    â•‘                                                           â•‘"
    echo "    â•‘        ${ROCKET} INSTALLATION COMPLETED! ${ROCKET}                    â•‘"
    echo "    â•‘                                                           â•‘"
    echo "    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"

    echo -e "${CYAN}${PACKAGE} What's installed:${NC}"
    echo "  â€¢ Cortex Code v$VERSION binary"
    echo "  â€¢ Default configuration"
    echo "  â€¢ AGENTS.md memory file"
    echo "  â€¢ Shell integration"
    echo "  â€¢ MCP server support"
    echo ""

    echo -e "${YELLOW}${GEAR} Next steps:${NC}"
    echo "  1. Restart your shell or run: source ~/.bashrc"
    echo "  2. Run: cortex-code --help"
    echo "  3. Start the interface: cortex-code"
    echo "  4. Or start daemon mode: cortex-code daemon"
    echo ""

    echo -e "${BLUE}${SPARKLES} Quick start:${NC}"
    echo "  cortex-code                    # Interactive mode"
    echo "  cortex-code chat \"Hello!\"       # Single question"
    echo "  cortex-code daemon             # Start HTTP server"
    echo "  cortex-code mcp list           # List MCP servers"
    echo ""

    echo -e "${PURPLE}Documentation: $REPO_URL${NC}"
    echo -e "${GREEN}Happy coding with Cortex! ${SPARKLES}${NC}"
}

main() {
    print_header
    
    log_info "Starting Cortex Code installation..."
    
    # Detect system
    detect_os
    detect_arch
    log_info "Detected platform: $OS-$ARCH"

    # Pre-installation checks
    check_dependencies

    # Installation steps
    download_binary
    setup_config
    setup_shell_integration
    install_mcp_servers
    verify_installation

    # Success!
    print_success_message
}

# Handle interruption gracefully
trap 'echo -e "\n${RED}Installation interrupted${NC}"; exit 1' INT TERM

# Run main installation
main "$@"
