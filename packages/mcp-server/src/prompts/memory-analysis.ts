/**
 * Memory Analysis Prompt
 *
 * Structured prompt for analyzing stored memories with
 * patterns, insights, and trend identification.
 */

import { createMemoryProviderFromEnv, type MemorySearchResult } from '@cortex-os/memory-core';
import type { z } from 'zod';
import type { PromptHandlerResult } from '../types/mcp-2025.js';
import { BRAND } from '../utils/brand.js';
import { MemoryAnalysisArgs } from './index.js';

type MemoryAnalysisInput = z.infer<typeof MemoryAnalysisArgs>;

const memoryProvider = createMemoryProviderFromEnv();

async function fetchSampleMemories(args: MemoryAnalysisInput): Promise<MemorySearchResult[]> {
	try {
		const results = await memoryProvider.search({
			query: args.query,
			limit: 5,
			offset: 0,
			search_type: 'hybrid',
			session_filter_mode: 'all',
		});
		return Array.isArray(results) ? results : [];
	} catch (error) {
		const message = error instanceof Error ? error.message : String(error);
		console.warn('[brAInwav] memory-analysis prompt search failed', message);
		return [];
	}
}

function buildStructuredAnalysis(args: MemoryAnalysisInput, memories: MemorySearchResult[]) {
	return {
		query: args.query,
		timeframe: args.timeframe ?? 'last 30 days',
		focus_areas: args.focus_areas ?? [],
		match_count: memories.length,
		sampled_memories: memories.slice(0, 3).map((memory) => ({
			id: memory.id,
			title: memory.content?.slice(0, 80) ?? 'Untitled memory',
			score: memory.score,
			url: `memory://cortex-local/${memory.id}`,
		})),
		insights: [
			`Located ${memories.length} candidate memories for follow-up`,
			args.focus_areas?.length
				? 'Focus areas provided; tailor analysis accordingly'
				: 'No focus areas supplied; recommend comprehensive sweep',
		],
		next_actions: [
			'Cluster related memories using memory.relationships for deeper context',
			'Record findings in memory.store to keep retrospectives searchable',
			'Validate metrics via metrics://cortex-os/health before shipping changes',
		],
	};
}

function renderAnalysisText(analysis: ReturnType<typeof buildStructuredAnalysis>): string {
	const focusSection =
		analysis.focus_areas.length > 0
			? analysis.focus_areas.map((item) => `- ${item}`).join('\n')
			: 'General memory review requested.';
	const samples =
		analysis.sampled_memories.length > 0
			? analysis.sampled_memories
					.map((mem) => `- (${mem.score?.toFixed(2) ?? 'n/a'}) ${mem.title} â†’ ${mem.url}`)
					.join('\n')
			: 'No existing memories matched the query.';

	return `# ${BRAND.prefix} Memory Analysis

**Query:** ${analysis.query}
**Timeframe:** ${analysis.timeframe}
**Matches:** ${analysis.match_count}

## Focus Areas
${focusSection}

## Sampled Memories
${samples}

## Insights
${analysis.insights.map((item, index) => `${index + 1}. ${item}`).join('\n')}

## Next Actions
${analysis.next_actions.map((item) => `- ${item}`).join('\n')}

---
*Generated by ${BRAND.prefix} Cortex Memory Server*`;
}

/**
 * Render memory analysis prompt with structured output
 */
export async function renderMemoryAnalysis(input: unknown): Promise<PromptHandlerResult> {
	const args = MemoryAnalysisArgs.parse(input) satisfies MemoryAnalysisInput;
	const memories = await fetchSampleMemories(args);
	const analysis = buildStructuredAnalysis(args, memories);
	return {
		structuredContent: analysis,
		text: renderAnalysisText(analysis),
	};
}
