/**
 * Incident Retro Prompt
 *
 * Structured prompt for generating incident retrospectives
 * with timeline, analysis, and action items.
 */

import type { z } from 'zod';
import { readHealthMetrics } from '../resources/metrics-provider.js';
import type { PromptHandlerResult } from '../types/mcp-2025.js';
import { BRAND } from '../utils/brand.js';
import { IncidentRetroArgs } from './index.js';

type IncidentRetroInput = z.infer<typeof IncidentRetroArgs>;

async function loadHealthSnapshot(signal?: AbortSignal) {
	try {
		const resource = await readHealthMetrics();
		// Resource can be text or blob, need to handle both
		const content = 'text' in resource ? resource.text : resource.blob;
		return JSON.parse(content);
	} catch (error) {
		const message = error instanceof Error ? error.message : String(error);
		console.warn('[brAInwav] incident-retro metrics failed', message);
		return null;
	}
}

function buildRetro(args: IncidentRetroInput, metrics: any) {
	return {
		incident_id: args.incident_id ?? `INC-${Date.now()}`,
		severity: args.severity,
		timeline: args.timeline ?? 'Timeline pending investigation.',
		affected_systems: args.affected_systems ?? [],
		sections: [
			{ name: 'What happened?', description: 'Chronological narrative and system signals.' },
			{ name: 'Impact assessment', description: 'User impact, service impact, and blast radius.' },
			{ name: 'Root cause', description: 'Primary cause with contributing factors.' },
			{ name: 'Mitigations', description: 'Steps taken to restore service.' },
			{ name: 'Action items', description: 'Preventative tasks with owners and due dates.' },
		],
		metrics_snapshot: metrics,
		metadata: {
			brand: BRAND.prefix,
			created_at: new Date().toISOString(),
			follow_up_date: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
		},
	};
}

function formatSystems(systems: string[]): string {
	return systems.length > 0
		? systems.map((item) => `- ${item}`).join('\n')
		: 'Systems pending confirmation.';
}

function renderRetroText(retro: ReturnType<typeof buildRetro>): string {
	const severityBadges: Record<string, string> = {
		low: 'ðŸŸ¢',
		medium: 'ðŸŸ¡',
		high: 'ðŸŸ ',
		critical: 'ðŸ”´',
	};
	const sections = retro.sections
		.map((section, index) => `### ${index + 1}. ${section.name}\n${section.description}`)
		.join('\n\n');
	return `# ${severityBadges[retro.severity]} ${BRAND.prefix} Incident Retrospective

**Incident ID:** ${retro.incident_id}
**Severity:** ${retro.severity.toUpperCase()}

## Timeline
${retro.timeline}

## Affected Systems
${formatSystems(retro.affected_systems)}

## Retrospective Sections
${sections}

## Metrics Snapshot
${retro.metrics_snapshot ? `\`\`\`json\n${JSON.stringify(retro.metrics_snapshot, null, 2)}\n\`\`\`` : 'Metrics snapshot unavailable.'}

## Follow-up
- **Review Date:** ${new Date(retro.metadata.follow_up_date).toISOString()}
- **Report Owner:** To be assigned

---
*Generated by ${BRAND.prefix} Cortex Memory Server*`;
}

/**
 * Render incident retro prompt with structured output
 */
export async function renderIncidentRetro(input: unknown): Promise<PromptHandlerResult> {
	const args = IncidentRetroArgs.parse(input) satisfies IncidentRetroInput;
	const metrics = await loadHealthSnapshot();
	const retro = buildRetro(args, metrics);
	return {
		structuredContent: retro,
		text: renderRetroText(retro),
	};
}
