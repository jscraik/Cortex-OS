name: Agent Gates (ChatOps)
on:
  issue_comment:
    types: [created]
permissions:
  contents: read
  pull-requests: write
jobs:
  a11y:
    if: ${{ startsWith(github.event.comment.body, '/gate a11y') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: "20" }
      - name: Run Playwright a11y tests (JSON)
        id: a11y
        run: |
          set +e
          npx -y playwright install --with-deps
          npx playwright test tests/a11y.ci.spec.ts --reporter json > a11y-report.json 2>&1
          echo "json<<EOF" >> $GITHUB_OUTPUT
          cat a11y-report.json >> $GITHUB_OUTPUT || true
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Upload a11y artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: a11y-report-${{ github.run_id }}
          path: |
            a11y-report.json
            playwright-report/**
            test-results/**
          if-no-files-found: warn
      - name: Summarize a11y results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let summary = 'üß™ a11y gate executed via Playwright. JSON report attached as artifact.';
            try {
              const raw = fs.readFileSync('a11y-report.json', 'utf8');
              const data = JSON.parse(raw);
              // Playwright JSON can contain "suites" -> tests, or flattened "tests"
              const tests = data.tests || [];
              let passed = 0, failed = 0;
              const failures = [];
              // Recursively collect axe violations by rule id if present in any attachments/logs
              const ruleAgg = new Map(); // id -> {count, selectors:Set}
              const collectViolations = (node) => {
                if (!node || typeof node !== 'object') return;
                if (Array.isArray(node)) { node.forEach(collectViolations); return; }
                if (Array.isArray(node.violations)) {
                  for (const v of node.violations) {
                    const id = v.id || 'unknown';
                    const count = Array.isArray(v.nodes) ? v.nodes.length : 1;
                    const rec = ruleAgg.get(id) || { count: 0, selectors: new Set() };
                    rec.count += count;
                    if (Array.isArray(v.nodes)) {
                      for (const n of v.nodes) {
                        if (Array.isArray(n.target)) {
                          n.target.slice(0,2).forEach(sel => rec.selectors.add(String(sel).slice(0,160)));
                        }
                      }
                    }
                    ruleAgg.set(id, rec);
                  }
                }
                for (const k of Object.keys(node)) collectViolations(node[k]);
              };
              collectViolations(data);
              for (const t of tests) {
                if (t.status === 'passed') passed++; else failed++;
                if (t.status !== 'passed') {
                  failures.push(`- ${t.title || t.name || 'Unnamed test'}`);
                }
              }
              const rulesList = Array.from(ruleAgg.entries()).sort((a,b)=>b[1].count-a[1].count).slice(0, 10)
                .map(([id, rec]) => {
                  const link = `https://dequeuniversity.com/rules/axe/${id}`;
                  const sels = Array.from(rec.selectors).slice(0,3).map(s=>`\`${s}\``).join(', ');
                  return `- ${id}: ${rec.count} [docs](${link})${sels ? ` ‚Äî selectors: ${sels}` : ''}`;
                });
              const rulesBlock = rulesList.length ? ['\nTop axe violations (by nodes):', ...rulesList].join('\n') : '';
              summary = `üß™ a11y gate: ${passed} passed, ${failed} failed.\n` + (failures.length ? ['\nFailures:', ...failures].join('\n') : '') + (rulesBlock ? `\n${rulesBlock}` : '') + '\n\nDocs: see packages/sdk/README.md for a11y-friendly starter usage.';
            } catch (e) {
              summary += ' (failed to parse JSON summary)';
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: summary + '\n\nArtifacts include the full JSON report.'
            });
  security:
    if: ${{ startsWith(github.event.comment.body, '/gate security') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: OSV scan
        uses: google/osv-scanner-action@v1
        with: { path: "." }
      - name: Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITLEAKS_LICENSE: oss
      - name: Semgrep (privacy)
        uses: returntocorp/semgrep-action@v1
        with: { config: p/owasp-top-ten, enable_metrics: false }
      - name: Comment security results
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: 'üîê security gate executed (OSV, gitleaks, semgrep). See Actions logs for details.'
            });
  docs:
    if: ${{ startsWith(github.event.comment.body, '/gate docs') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: "20" }
      - run: npm i -g markdownlint-cli
      - name: Markdownlint
        run: npx markdownlint **/*.md --ignore node_modules || true
      - name: Render Mermaid diagrams
        run: node scripts/render-mermaid.mjs || true
      - name: Upload Docs Artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: docs-artifacts-${{ github.run_id }}
          path: |
            docs/**/diagrams/*.svg
          if-no-files-found: ignore
      - name: Comment docs results
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: 'üìù docs gate executed (markdownlint + mermaid render). Artifacts uploaded if any.'
            });
  perf:
    if: ${{ startsWith(github.event.comment.body, '/gate perf') }}
    runs-on: ubuntu-latest
    steps:
      - name: Try Vercel Deployments API (latest preview)
        if: ${{ !startsWith(github.event.comment.body, '/gate perf http') }}
        id: vercel_api
        uses: actions/github-script@v7
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
        with:
          script: |
            const token = process.env.VERCEL_TOKEN;
            const projectId = process.env.VERCEL_PROJECT_ID;
            const orgId = process.env.VERCEL_ORG_ID;
            if (!token || !projectId || !orgId) {
              core.info('Vercel API secrets not configured; skipping API autodetect.');
              return;
            }
            const url = new URL('https://api.vercel.com/v6/deployments');
            url.searchParams.set('projectId', projectId);
            url.searchParams.set('limit', '25');
            url.searchParams.set('orgId', orgId);
            const res = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
            if (!res.ok) {
              core.warning(`Vercel API response not ok: ${res.status}`);
              return;
            }
            const data = await res.json();
            const deployments = (data.deployments || []).filter(d => d?.target === 'preview' && d?.readyState === 'READY');
            const prNum = context.payload?.issue?.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            let found = null;
            for (const d of deployments) {
              const meta = d?.meta || {};
              if (prNum && String(meta['github-pr']) === String(prNum)) { found = d; break; }
              if (meta['github-repo-owner'] === owner && meta['github-repo'] === repo) { found = d; break; }
            }
            if (!found && deployments.length) found = deployments[0];
            if (found?.url) {
              const previewUrl = `https://${found.url}`;
              core.setOutput('url', previewUrl);
              core.summary.addHeading('Perf Gate ‚Äì Autodetected from Vercel API').addLink(previewUrl, previewUrl).write();
            } else {
              core.info('No READY Vercel preview deployment found.');
            }
      - name: Parse perf URL from command
        id: parse
        run: |
          BODY='${{ github.event.comment.body }}'
          URL=$(echo "$BODY" | awk '{print $3}')
          echo "url=$URL" >> $GITHUB_OUTPUT
      - name: Autodetect Vercel preview URL (fallback)
        if: ${{ (steps.vercel_api.outputs.url == '' || !steps.vercel_api.outputs.url) && (steps.parse.outputs.url == '' || steps.parse.outputs.url == 'auto') }}
        id: autodetect
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const num = context.payload.issue.number;
            const comments = await github.paginate(github.rest.issues.listComments, {owner, repo, issue_number: num, per_page: 100});
            const re = /(https?:\/\/[^\s]*vercel\.app[^\s]*)/ig;
            let found = null;
            for (const c of comments.slice().reverse()) {
              const m = c.body && c.body.match(re);
              if (m && m[0]) { found = m[0]; break; }
            }
            if (found) {
              core.setOutput('url', found);
              core.summary.addHeading('Perf Gate ‚Äì Autodetected URL').addRaw(found).write();
            } else {
              core.setFailed('Preview URL not provided and no vercel.app link found in comments. Use: /gate perf <url>');
            }
      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v11
        with:
          urls: ${{ steps.vercel_api.outputs.url || (steps.parse.outputs.url != '' && steps.parse.outputs.url != 'auto' && steps.parse.outputs.url) || steps.autodetect.outputs.url }}
          uploadArtifacts: true
          budgetPath: config/lighthouse-budget.json
          configPath: ""
      - name: Comment perf results
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `‚ö° perf gate executed for: ${{ steps.vercel_api.outputs.url || (steps.parse.outputs.url != '' && steps.parse.outputs.url != 'auto' && steps.parse.outputs.url) || steps.autodetect.outputs.url }}. See Lighthouse artifacts in the run.`
            });
  sbom:
    if: ${{ startsWith(github.event.comment.body, '/gate sbom') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Generate SBOMs
        run: |
          npm run sbom:generate || pnpm sbom:generate || true
          ls -la
      - name: Validate licenses against policy
        id: license
        continue-on-error: true
        run: |
          echo "Running license:validate to check for disallowed licenses..."
          npm run license:validate || pnpm license:validate
      - name: Fail on license violations
        if: ${{ steps.license.outcome == 'failure' }}
        run: |
          echo "Disallowed licenses detected by license:validate. Failing gate." && exit 1
      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-artifacts-${{ github.run_id }}
          path: |
            sbom*.json
            **/sbom*.json
          if-no-files-found: warn
      - name: Comment SBOM results
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `üì¶ SBOM gate executed. SBOM artifacts uploaded.${{ steps.license.outcome == 'failure' && ' ‚ùå Disallowed licenses found; gate failed.' || '' }}`
            });
